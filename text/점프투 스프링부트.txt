
스프링부트 프로젝트 기본 구조

ORM

JPA

엔티티

=================================================================================

스프링부트 프로젝트 기본 구조

- src/main/java 디렉토리

스프링부트 컨트롤러, 폼, DTO, 데이터베이스 처리를 위한 엔티티, 서비스 파일 등 작성하는 공간.



- 프로젝트명 + Application.java 파일

스프링부트 어플리케이션에서 시작을 담당하는 파일. (자동생성)
application 클래스 위에는 반드시 @SpringBootApplication 어노테이션 존재해야 한다. -> 모든 설정 관리



- templates 디렉토리

(src/main/resources 디렉토리 하위) 디렉토리인 templates 디렉토리에는 템플릿 파일을 저장한다.
템플릿 파일은 HTML 파일 형태로 자바 객체와 연동되는 파일. templates 디렉토리에는 질문목록, 질문 상세 등의 html 파일 저장.



- static 디렉토리
(src/main/resources 디렉토리 하위) 프로젝트 css, js, 이미지 파일 등을 저장하는 공간.



- application.properties

(src/main/resources 디렉토리 하위) 프로퍼티 파일은 프로젝트  환경 설정 역할.
프로젝트 환경, DB 설정 등을 이 파일에 저장.



- src/test/java 디렉토리

프로젝트에서 작성한 파일을 테스트하기 위한 테스트 코드 작성 공간.
JUnit과 스프링부트 테스팅 도구 사용하여 서버를 실행하지 않은 상태에서 src/main/java 디렉토리 작성 코드 테스트.



- build.gradle 파일

그레이들이 사용하는 환경 파일. ant, maven과 같은 이전 세대 빌드 도구의 단점을 보완하고 장점을 취합하여 만든 빌드 도구.
build.gradle 파일에는 프로젝트를 위한 필요한 플러그인과 라이브러리 등을 기술.

--------------------------------------------------------------------------------------------------------------------------------------------------

ORM (Object Relational Mapping)

객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것
DB에 데이터를 저장하는 테이블을 자바 클래스로 만들어 관리 가능하게 해주는 기술.
DB 종류와 상관없이 일관된 코드 유지 가능.
유지보수 용이 / 개발자가 달라도 통일된 쿼리 작성 가능 / 오류 발생률 낮아짐

-------------------------------------------------------------------------------------------------------------------------------------------------

JPA (Java Persistence API)

자바진영에서 ORM의 기술표준으로 사용하는 인터페이스 모음

JPA는 인터페이스이므로 구현하는 실제 클래스 필요.
대표적 클래스에는 하이버네이트가 있다.

--------------------------------------------------------------------------------------------------------------

엔티티

DB 테이블과 매핑되는 자바 클래스.

클래스위에 @Entity 달아줘야 한다. (@Controller 사용과 동일)

 - 사용되는 어노테이션들

@Id
 - PK 지정

@GeneratedValue(strategy = GenerationType.IDENTITY)
 - 값 저장시 해당 속성값을 따로 지정하지 않아도 1씩 증가하며 세팅.
 - strategy는 채번 규칙. GenerationType.IDENTITY는 해당 컬럼만의 독립적 시퀀스를 사용한다는 뜻.
   이를 지정하지 않으면 다른 컬럼들과 시퀀스를 공유하므로 일정한 순서의 고유번호를 생성하지 못한다.

@Column
 - 해당 속성을 컬럼으로 지정.
   사실 지정하지 않아도 알아서 인식하기 때문에, 이걸 달아주는 경우는 속성의 속성을 지정하기 위함.
  ex) @Column(length = 200)	@Column(columnDefinition = "TEXT")
        컬럼 길이 200		   컬럼길이 지정 어려울 경우 TEXT 속성으로 지정 (변동)
 - 따라서 컬럼이 아니라고 지정하려면 @Transient를 달아주어야 한다.

* 엔티티 클래스 속성은 자바이므로 카멜케이싱을 따르는데,
   이는 DB로 넘어가면서 자동으로 스네이크케이싱에 맞춰진다. ex) createDate -> create_date

* 일반적으로 엔티티는 setter 구현하지 않고
   롬복의 @Builder 통한 빌드패턴 사용하고, 데이터 변경시에는 필요한 메소드를 엔티티에 추가하여 사용한다.




게시판에서 사용할 질문과 답변 엔티티를 하나씩 만드는 경우,
질문과 답변은 서로 매칭될 수 있기 때문에 상호 엔티티에 상호 속성을 하나씩 넣어줄 수 있다.
private Question question;
private Answer answer;

질문 하나에 답변이 여러개 달리기 때문에 
Asnwer 엔티티속 Question 속성에는 @ManyToOne 어노테이션을
Question 엔티티속 Answer 속성에는 @OneToMany 어노테이션을 달아준다.
-> 이 때 답변이 여러개로 관리되므로 Question 엔티티속 Answer 속성은 private List<Answer> answerList; 이럭헤 리스트로 만들어 준다.

* OneToMany에 줄 수 있는 옵션 예시
 (mappedBy = "question", cascade = CascadeType.REMOVE)
-> mappedBy는 참조 엔티티 속성명을 의미하므로 Answer엔티티 속 Question 속성명인 question 부여.
-> cascade는 삭제시 처리 방법으로, 질문 삭제시 답변도 모두 삭제되어야하므로 CascadeType.REMOVE 지정.

ManyToOne, OneToMany는 FK 지정이다.

--------------------------------------------------------------------------------------------------------------
















